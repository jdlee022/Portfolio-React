{
  "title": "How To Build A Blog With React, Node, Express, and MySQL",
  "textMD": "# How To Build A Blog With React, Node, Express, and MySQL\n\n## Overview\n\nThis tutorial will go through the step by step process of how to create a single page blog website with the MERN stack (~~MongoDB~~, MySQL, Express, React, Node). The contents are the foundation on which this blog was built.\n\n### Prerequisites\n\n* Node/NPM installed.\n* MySQL installed.\n* Basic understanding of React.\n* Familiarity with ES6 JavaScript.\n\n### What this guide covers\n\n* How to get started with create-react-app.\n* How to setup a MySQL database.\n* How to create our own API via Express.\n* How to use that API to interact with the database and dynamically render React components.\n\n## First steps\n\nWe will be using Facebook's very own Create React App to get up and running so if you haven't already, install the CLI by running `npm i -g create-react-app`. Now we're going to change into the directory that we want to create our project and run\n\n`mkdir mernblog && cd mernblog`\n\n`create-react-app client`\n\nNow if we `cd client` and run `npm start` we should have the default app running in our browser:\n\nLet's do a bit of file restructuring -- create a `/components` folder in the `/src` directory and remove the following files (we won't be needing them): `App.css App.test.js favicon.ico index.css logo.svg`. Don't forget to remove the `index.css` import in the `index.js` file. Our file structure at the end of the tutorial will look like this:\n\n```\n- client\n    - node_modules\n    - public\n    - src\n        - components\n            - App.js\n            - Archive.js\n            - PostPage.js\n            - PostPreview.js\n            - style.css\n            - utilities\n                - API.js\n        - App.js\n        - index.js\n        - style.js\n    - package.json\n- node_modules\n- server\n    - config\n    - migrations\n    - models\n        - index.js\n        - post.js\n    - routes\n        - blogRoutes.js\n    - seeders\n    - index.js\n- .gitignore\n- package.json\n- README.md\n```\n\n## Dependencies\n\nBefore we move any further let's install all of the dependencies we will need for the blog.\n\n`npm i react-router react-router-dom bootstrap markdown-to-jsx axios --save`\n\nWe will need a separate package.json configuration for our server, so cd to the root directory of our project (one level above `client`) and run\n\n`npm init`\n\n`npm i mysql mysql2 sequelize express express-session body-parser cookie-parser morgan nodemon --save`\n\n* React-Router: provides routing functionality for our single page web app.\n* React-Router-Dom: needed for react-router (V4).\n* Bootstrap: helps with quick and easy styling.\n* Markdown-To-JSX: used to parse our blog posts written in markdown so that they can be rendered in a React component.\n* MySQL: our database.\n* Sequelize: an ORM that will interface with the MySQL database for us.\n* Axios: lets us use promise based HTTP methods to communicate with our database.\n* Express: provides a framework to set up our Node.js server.\n* Body Parser: parse the incoming requests bodies for the info we are sending (gives us access to req.body).\n* Nodemon: watches our server.js file for changes, then restarts it automatically.\n\n## React-Router\n\nReplace the contents of /src/App.js with the following code:\n\n```javascript\n// src/App.js\nimport React from 'react';\nimport { BrowserRouter, Route } from 'react-router-dom';\n\n//Import bootstrap first so we don't overwrite our own styles\nimport 'bootstrap/dist/css/bootstrap.css';\nimport 'bootstrap/dist/css/bootstrap-theme.css';\n\nimport Blog from './components/Blog';\n\nexport default () =&gt; (\n    &lt;BrowserRouter&gt;\n        &lt;Route path=\"/\" exact render={props =&gt; &lt;Blog {...props} /&gt;} /&gt;\n    &lt;/BrowserRouter&gt;\n);\n```\n\nand temporarily replace the contents of /components/Blog.js with:\n\n```javascript\n// components/Blog.js\nimport React from 'react';\nimport './style.css';\n\nexport default class Blog extends React.Component {\n      render() {\n        return <h1>React Router is working!</h1>;\n      }\n}\n```\n\nYou should now see the text indicating that react router is working when you hit localhost:3000/. The first block of code essentially tells react router to display our blog component whenever the index route is hit. We will be using react router 4 inside our components later in the tutorial.\n\n## Building a back-end with Node, Express, and MySQL\n\n### Express\n\nWe're going to sidetrack for a little bit and build out our back-end. First, create a `/server` folder in the root directory of our project, create the `index.js` and `app.js` files within that folder, and paste the following code into them:\n\n```javascript\n// server/app.js\nconst express = require('express');\nconst morgan = require('morgan');\nconst path = require('path');\nvar bodyParser = require('body-parser');\nconst app = express();\n\n// Setup logger\napp.use(morgan(':remote-addr - :remote-user [:date[clf]] \":method :url HTTP/:http-version\" :status :res[content-length] :response-time ms'));\n\n// Serve static assets\napp.use(express.static(path.resolve(__dirname, '..', 'build')));\n\n//BodyParser Middleware\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\n\n// Routes\nrequire(\"./routes/blogRoutes.js\")(app);\n\n// Always return the main index.html, so react-router render the route in the client\napp.get('*', (req, res) => {\n    res.sendFile(path.resolve(__dirname, '..', 'build', 'index.html'));\n});\n\nmodule.exports = app;\n```\n\nThe above code essentially creates our Express app and exports it to be synced with our (soon to be created) database in the index.js file below. You'll also notice an unfamiliar blogRoutes.js file being required, this will contain the routes used to communicate with our database -- more on that soon.\n\n```js\n// server/index.js\n'use strict';\n\nconst app = require('./app');\n\nconst PORT = process.env.PORT || 3001;\n\n// Requiring our models for syncing\nvar db = require(\"./models\");\n\n// Syncing our sequelize models and then starting our express app\ndb.sequelize.sync().then(function () {\n    app.listen(PORT, () => {\n    console.log(`App listening on port ${PORT}!`);\n    });\n});\n```\n\nIn order to hit our server routes at port 3001 from our React app we need to make a small modification to our `/client/package.json` file. Add `\"proxy\": \"http://localhost:3001\"` somewhere in the JSON object. This tells our app to hit the port 3001 (where we set up our server routes) whenever we make a request from the client (port 3000).\n\n### MySQL\n\nIf you haven't already, install the Sequelize CLI `npm install -g sequelize-cli`. This will help us get our database up and running with some boilerplate code. Now cd into the `/server` folder and run `sequelize init`.\n\nNote that the newly created models folder is what is being required into our `/server/index.js` file as the db. This is where we will create the schema for our blog posts. The `/model/index.js` file that was automatically created for us by Sequelize does a great job of managing our MySQL tables for us. If we create a new Schema in the models folder, Sequelize will automatically create a table for us if it doesn't already exist in our database. Don't forget to update the username and password in the config.json file to connect to your local database. Create a `post.js` file in the models folder and paste the following Schema (or your own modified version of it):\n\n```js\n// models/post.js\nmodule.exports = function (sequelize, DataTypes) {\n    var Post = sequelize.define(\"Post\", {\n        title: {\n            type: DataTypes.TEXT,\n            allowNull: false,\n            validate: { len: [1] }\n        },\n        textMD: {\n            type: DataTypes.TEXT,\n            allowNull: false,\n            validate: { len: [1] }\n        },\n        excerpt: {\n            type: DataTypes.TEXT,\n            allowNull: false,\n            validate: { len: [1] }\n        },\n        date: {\n            type: DataTypes.STRING,\n            allowNull: true,\n            defaultValue: null\n        },\n        featured: {\n            type: DataTypes.BOOLEAN,\n            allowNull: true,\n            default: false\n        },\n        tags: {\n            type: DataTypes.STRING,\n            allowNull: true\n        }\n    });\n    return Post;\n};\n```\n\nSo we have our Schema, but how do we actually interact with the table that gets created by Sequelize? In order to Create, Read, Update, and Delete data we need to implement some routes. Create a routes folder in the server directory and a blogRoutes.js file inside it.\n\n```js\n// routes/blogRoutes.js\nvar db = require(\"../models\");\n\nmodule.exports = function (app) {\n    // GET all posts from the database\n    app.get(\"/api/post/all\", function (req, res) {\n        db.Post.findAll({}).then(function (data) {\n            res.json(data);\n        })\n    });\n\n    // GET a post by its id\n    app.get(\"/api/post/:id\", function (req, res) {\n        db.Post.findOne({ where: { id: req.params.id } }).then(function (data) {\n            res.json(data)\n        });\n    });\n\n    // GET all featured posts\n    app.get(\"/api/post/featured\", function (req, res) {\n        db.Post.findAll({ where: { featured: true } }).then(function (data) {\n            res.json(data)\n        });\n    });\n\n    // POST a new post object to the database\n    app.post(\"/api/post\", function (req, res) {\n        db.Post.create({\n            title: req.body.title,\n            textMD: req.body.textMD,\n            excerpt: req.body.excerpt,\n            date: req.body.date,\n            featured: req.body.featured,\n            tags: req.body.tags\n        }).then(function (data) {\n            res.json(data);\n        });\n    });\n\n    // DELETE a post by it's id\n    app.delete('/api/post/:id', function (req, res) {\n        db.Post.destroy({ where: { id: req.params.id } });\n    });\n\n    // UPDATE a post by it's id\n    app.patch('/api/post/:id', function (req, res) {\n        db.Post.find({ where: { id: req.params.id } })\n            .on('success', function (post) {\n                // Check if record exists in db\n                if (post) {\n                    post.updateAttributes({\n                        title: req.body.title,\n                        textMD: req.body.textMD,\n                        excerpt: req.body.excerpt,\n                        date: req.body.date,\n                        featured: req.body.featured,\n                        tags: req.body.tags\n                    })\n                        .success(function () { })\n                }\n            })\n    });\n};\n```\n\nHere we've created a RESTful API that uses the standard HTTP protocol. Let's test our API with [Postman](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en). First we'll try creating a new blog post using the POST method and hitting the route we created earlier.\n\nGreat! we got the response we expected. After creating a few more dummy posts we can hit our GET route to find all posts.\n\nWe have the routes on the server side working but we still need to set up a Controller to enable our frontend (View) to communicate with our database (Model).\n\n## Connecting the dots\n\nIn order to dynamically generate our React components we need to create an API for the client side. Create a utilities folder under components and make an API.js file inside of it.\n\n```js\n// components/utilities/API.js\nimport axios from 'axios';\n\nvar blogAPI = {\n    getAllPosts: function(){\n        return axios.get('/api/post/all');\n    },\n\n    getPostByTitle: function(title){\n        return axios.get('/api/post/' + title);\n    },\n\n    getPostById: function(id){\n        return axios.get('/api/post/' + id);\n    },\n\n    getFeaturedPosts: function(){\n        return axios.get('/api/post/featured');\n    },\n\n    newPost: function(post){\n        return axios.post('/api/post', post);\n    }\n}\n\nexport default blogAPI;\n```\n\nAxios is an npm package that lets us make XMLHttpRequests from the browser, so we can import the above API into our React components to GET and POST data to our database. Create and update the following React components:\n\n```js\n// components/Blog.js\nimport React from 'react';\nimport { Route, Link } from 'react-router-dom';\nimport Archive from './Archive';\nimport PostPage from './PostPage';\nimport './style.css';\n\nexport default class Blog extends React.Component {\n    render() {\n        return (\n            <div className=\"container blog-container\">\n                <header className=\"row\">\n                    <div className=\"col-md-12\">\n                        <h1 id=\"blog-header\">John Smith</h1>\n                        <h4 id=\"blog-sub-header\">Insert tagline here.</h4>\n                    </div>\n                </header>\n\n                <div className=\"blog-content row\">\n                    <div className=\"post-preview-container col-md-9\">\n                        <Route exact={true} path=\"/\" component={Archive} />\n                        <Route path=\"/post/:id\" render={({ match }) => (\n                            <PostPage id={match.params.id} />\n                        )} />\n                    </div>\n                    <div className=\"sidebar col-md-3\">\n\n                        <img id=\"sidebar-img\" src=\"http://petattack.com/wp-content/uploads/2014/05/black-pug.jpg\" alt=\"pup\" />\n                        <p>Vestibulum ac diam sit amet quam vehicula elementum sed sit amet dui. Vivamus suscipit tortor eget felis porttitor volutpat. Curabitur arcu erat, accumsan id imperdiet et, porttitor at sem. Sed porttitor lectus nibh. Praesent sapien massa, convallis a pellentesque nec, egestas non nisi.\n                        </p>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n```\n\nHere we make use of React Router in the blog-content row. The two Route statements essentially tell React to render the Archive component if the index route is being hit, or the PostPage component if a post route is being hit.\n\n```js\n// components/Archive.js\nimport React from 'react';\nimport API from '../utilities/routes/blogAPI';\nimport PostPreview from './PostPreview';\n\nexport default class Archive extends React.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            posts: []\n        }\n    }\n\n    componentDidMount(){\n        API.getAllPosts().then((response) => {\n            this.setState({ posts: response.data });\n        })\n    }\n\n    render() {\n        var postPreviewItems = this.state.posts.map((post, i) =>\n            <PostPreview data={post} key={i} />\n        );\n        return <div>{postPreviewItems}</div>;\n    }\n};\n```\n\nWhenever this component renders we make an API call to get all of the posts from our database and update the state of the component. We then render a list of PostPreview components after passing each element the data corresponding to each individual post.\n\n```js\n// components/PostPreview.js\nimport React from 'react';\nimport { Link } from 'react-router-dom'\n\nexport default class PostPreview extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = this.props.data;\n    }\n\n    render() {\n        var postQuery = \"/post/\" + this.state.id;\n\n        return (\n            <div className=\"post-preview-item row\">\n                <div className=\"col-md-3 left-side\">\n                    <p className=\"post-preview-date\">{this.state.date}</p>\n                    <p className=\"post-preview-tags\">Tags: {this.state.tags}</p>\n                </div>\n                <div className=\"col-md-9 right-side\">\n                    <Link to={postQuery} className=\"post-preview-title\">{this.state.title}</Link>\n                    <p className=\"post-preview-excerpt\">{this.state.excerpt}</p>\n                </div>\n            </div>\n        );\n    }\n}\n```\n\nThis component receives a post's data through props and constructs a little preview of the post that displays the title, date, tags, and excerpt. Notice that we are using React Router once again to create a Link element so that whenever a user clicks on the title it will hit a new post route with the id of the post. When this happens the blog-content will stop displaying the Archive and start displaying a PostPage.\n\n```js\n// components/PostPage.js\nimport React from 'react';\nimport Markdown from 'markdown-to-jsx';\nimport API from '../utilities/routes/blogAPI';\n\nexport default class PostPage extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            title: '',\n            date: '',\n            tags: '',\n            textMD: ''\n        }\n    }\n\n    componentDidMount(){\n        API.getPostById(this.props.id).then((response) => {\n            this.setState({\n                title: response.data.title,\n                date: response.data.date,\n                tags: response.data.tags,\n                textMD: response.data.textMD\n            });\n        })\n    }\n\n    render() {\n        return (\n            <Markdown>{this.state.textMD}</Markdown>\n        );\n    }\n}\n```\n\nNotice that we are once again using the API, this time to get data for a specific post based on the id passed through props. We have also imported the Markdown package to display the posts that we write in markdown.\n\nBefore we run our application we need to make sure that our root `package.json` has the following script(s)\n\n```javascript\n\"scripts\": {\n    \"start\": \"node server\",\n    \"heroku-postbuild\": \"cd client && npm install --only=dev && npm install && npm run build\" // if we are using Heroku deployment\n  }\n```\n\nNow to run the app locally on our machine we cd into our project's root directory to run the server (`npm start`), and then open up another terminal to cd into the client to start-up React (`npm start`).\n\nThat's pretty much it! If you add a little HTML and CSS you get the blog page that you're looking at right now. Of course, there can be many improvements to what we've created in this tutorial. For example, you can try creating a search bar that let's users search for specific posts, or you could create some buttons that allow for easier navigation between the Archive and PostPages. I am going to continue working on this blog and will update this post if I make any significant changes. Until then, happy coding!",
  "excerpt": "This tutorial will go through the step by step process of how to create a single page blog website with the MERN stack (MySQL, Express, React, Node). ",
  "date": "Oct. 6th, 2017",
  "featured": false,
  "tags": "JavaScript, Node, React, Express, MySQL, tutorial"
}