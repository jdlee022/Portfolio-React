{
  "title": "What's New In ES6?",
  "textMD": "# What's New In ES6?\n\nES6 is the next generation of JavaScript that brings a lot of quality of life improvements for the JavaScript developer. Here we have a look at some of its key features. The majority of these notes were taken from Ben Ilegbodu's [Learning ES6 Series](https://www.eventbrite.com/engineering/tag/learning-es6/) which I highly recommend to anyone who wants to dive deeper into the details of these new features.\n\n## Var vs Let vs Const\n\n### Let has block scope\n\nThe key difference between `let` and `var` when defining a new variable is that `var` has **functional** scope while `let` has **block** scope. This means that a `let` variable is local to things like `for` loops and `if` statements while `var` is not. This new keyword is very useful whenever we only need to hold on to a variable for a short amount of time and we don't want it potentially getting mixed up with our variables in a larger scope.\n\n```js\nif(true){\n    var x = 10;\n    let y = 5;\n    console.log(x); // 10\n    console.log(y); // 5\n}\nconsole.log(x); // 10\nconsole.log(y); // error: y is not defined\n```\n\n### Loops and let\nUnsurprisingly, `let` can be very useful in loops (since loops are considered to be blocks). The iteration variable declared with `var` is available outside of the `for` loop which can cause problems when developers create callback functions within loops. Changing the iteration variable to `let i = 0` in the code below will solve the bug because each button will be referring to the variable that was defined in its own **block**.\n\n```js\nfunction foo() {\n    var body = $('body');\n    for (var i = 0; i < 5; i++) {\n        var button = $('<button>var ' + i + '</button>');\n        button.click(\n            // BUG: the value of i will always be 5 since they reference the same var\n            () => console.log('var button ' + i + ' clicked!')\n        );\n        body.append($button);\n    }\n}\nfoo();\n```\n\n### Const\nThe `const` keyword also uses block scope and it allows us to define immutable variables. It also differs from the `let` keyword in that it must be initialized with a value immediately. This is extremely useful whenever we know for certain that a variable should never be changed in our code. It allows us to cut down on errors when dealing with a large code base that might reuse variable names. `Const` variables are typically declared with variable names that are in all caps.\n\nIt is worth noting that variables defined with `let` and `const` will essentially be treated as `var` variables during runtime. The new ES6 ways of declaring variables will throw errors at compilation time if something is wrong.\n\n```js\nconst PORT = 3000;\nPORT = 5000; // error: assignment to constant variable\n\nif(true){\n    const PORT = 8080;\n    console.log(PORT); // 8080\n}\nconsole.log(PORT); // 3000\n```\n\n### When to use let and const\n\nIn general you always want to use `let` over `var`. It just makes your code less likely to cause unsuspecting bugs by making sure that you're referencing the variable you really mean to be referencing at compile time. The only time you really need to use `var` is for objects in the global scope, especially when using ES5 modules. The `const` keyword should be used whenever you know for a fact that a variable should never be changed. This works best for primitive values because objects defined with `const` can still be changed (use `Object.freeze` instead), which defeats its purpose and can cause confusion.\n\n## Data Types\n\nHere is a brief overview of the data types that are available in JavaScript in ES6.\n\n```js\nconsole.log(typeof true); // boolean\nconsole.log(typeof 3.14); // number\nconsole.log(typeof \"hello world\"); // string\nconsole.log(typeof Symbol()); // symbol\nconsole.log(typeof {foo: 1}); // object\nconsole.log(typeof [1, 2, 3]); // object\nconsole.log(typeof null); // object\nconsole.log(typeof undefined); // undefined\n```\n\n### Strings\n\nThe cool thing about strings in ES6 is that you can use something called **template literals**. This lets us refer to a variable's value inside a string by calling its name inside of back ticks.\n\n```js\nlet first_name = \"satoshi\";\nlet last_name = \"nakamoto\";\nconsole.log(`${first_name} ${last_name} is my name`); // \"satoshi nakamoto is my name\"\n\nlet num1 = 5;\nlet num2 = 10;\nconsole.log(`5 * 10 = ${num1 * num2}`); // \" 5 * 10 = 50\"\n```\n\nYou can also use something called **tag template literals** to modify output using a function. Note that the rest parameter syntax ( `...` ) allows us to represent an indefinite number of arguments as an array, so it becomes an array whose elements from 0 to `theArgs.length` are supplied by the actual arguments passed to the function **which are not given a name**.\n\n```js\nfunction doMath(strings, ...values){\n    if(strings[0] == 'Add'){\n        console.log(`${values[0]} + ${values[1]} = ${values[0] + values[1]}`);\n    } else if(strings[0] == 'Sub'){\n       console.log(`${values[0]} - ${values[1]} = ${values[0] - values[1]}`);\n    }\n}\n\ndoMath `Add${10} ${20}`; // \"10 + 20 = 30\"\ndoMath `Sub${10} ${2}`; // \"10 - 2 = 8\"\n```\n\nWe can also loop over the characters in a string.\n\n```js\nlet first_name = \"satoshi\";\nfor(let c of first_name){\n    console.log(`${c}`);\n}\n```\n\nWe can repeat strings with the new `repeat()` function.\n\n```js\nconsole.log(\"blah\".repeat(3)); // \"blah blah blah\"\n```\n\nWe can check if a string starts with, ends with, or includes a specific value.\n\n```js\nlet first_name = \"satoshi\";\nconsole.log(first_name.startsWith(\"sa\")); // true\nconsole.log(first_name.endsWith(\"ho\")); // false\nconsole.log(first_name.includes(\"tosh\")); // true\n```\n\nWe can create multi-line strings using backslashes or back ticks.\n\n```js\nlet multilineStr = \"this is \\ \na multiline \\ \nstring\";\n\nlet multiStr2 = `this is\na multiline\nstring`;\n\nconsole.log(multilineStr); // \"this is a multiline string\"\nconsole.log(multiStr2); // \"this is a multiline string\"\n```\n\n## Symbols\n\nSymbols are enumerated types that can by used as identifiers which are immutable.\n\n```js\nlet capital = Symbol(\"State Capital\");\n\nlet pennsylvania = {};\n\npennsylvania[capital] = \"Harrisburg\";\nconsole.log(`Capital of PA : ${pennsylvania[capital]}`); // \"Capital of PA: Harrisburg\"\nconsole.log(`Symbol Capital : ${capital.toString()}`); // \"Symbol Capital : Symbol(State capital)\"\n```\n\n## Functions\n\n### Default parameters\n\nIn ES6 we are able to set default values for our parameters. Parameters with a default value are considered to be optional, so if you have a parameter that is optional but doesn't have a default value, you may want to give it a default value of `undefined`. It is important to know that the arguments array will only know the value that was passed into the function, it will not include the default values.\n\n```js\nfunction getSum(num1 = 1, num2 = 2){\n    console.log(`${num1} + ${num2} = ${num1 + num2}`); // 3 + 2 = 5\n\n    console.log(`${arguments[0]} + ${arguments[1]}`); // 3 + undefined\n}\ngetSum(3);\n```\n\nOrdering matters when it comes to default parameters. You can define default parameters anywhere in the function header, but the values that are passed into the function are dependent on whether optional parameters come before or after parameters that do not have a default.\n\n```js\nfunction foo(a, b=5, c){\n    console.log(`a:${a}, b:${b}, c:${c}`);\n}\nfoo(); // a:undefined, b:5, c:undefined\nfoo(3); // a:3, b:5, c:undefined\nfoo(2,9); // a:2, b:9, c:undefined\nfoo(2, undefined, 3); // a:2, b:5, c:3\nfoo(2,null, 9); // a:2, b:null, c:undefined\n\n```\n\n### Rest and spread operators\n\nRest operators are treated as an array and consist of the parameter values which are not given a name. This should be able to replace the `arguments` special variable which consists of every single parameter, including the ones with names.\n\nWhile default parameters handles the case where a function is called with less parameters than what a function declares, rest operators handles the case where more parameters are passed. One difference between rest and default parameters is that there can only be one rest parameter in a function and it must be the last parameter, otherwise all parameters after the rest will be ignored.\n\n```js\nfunction multiply(multiplier, ...theArgs) {\n  return theArgs.map(function(element) {\n    return multiplier * element;\n  });\n}\nconsole.log(multiply(2, 1, 2, 3)); // [2, 4, 6]\n```\n\nSpread operators are essentially the opposite of rest operators, since spread operators separate arrays into zero or more parameters. They look exactly like rest operators ( `...` ), but they are used in function calls instead of function declarations. These new operators can be used to replace nearly all use cases of the `apply()` function. For example, compare the below ES5 code with the new ES6 way of merging an arbitrary number of objects into one single object.\n\n```js\nfunction merge() {\n    var masterObj = {};\n    for (var i = 0; i < arguments.length; i++) {\n        var obj = arguments[i];;\n        for (var key in obj)\n            masterObj[key] = obj[key];\n    }\n    return masterObj;\n}\n \nlet objectsList = [\n    {\n        foo: 9,\n        bar: 99,\n        bash: true,\n    },\n    {\n        bash: false\n    }\n];\n\n// ES5 way\nconsole.log(merge.apply(undefined, objectsList)); // {foo:9, bar:99, bash:false}\n\n// ES6 way\nconsole.log(merge(...objectsList)); // {foo:9, bar:99, bash:false}\n```\n\nOne of the most useful features of spread operators is that they can be used anywhere in the function call and are able to be used more than once. In some cases, like the example below, we would have to build new arrays if we wanted to use the ES5 `apply()` method.\n\n```js\n// continuing from the code above...\nconsole.log(merge({foo: 1}, ...objectsList, {bar: 'hello'}));  // {foo:9, bar:'hello', bash:false}\n```\n\n### Arrow functions\n\nArrow functions are a shorthand version of anonymous function expressions. They have a shorter syntax and do not have their own `arguments`, `super`, or `new.target`, they inherit these values from their enclosing scope. They are best suited for non-method functions, and they cannot be used as constructors.\n\nOne of the major features of arrow functions is their lexical `this` variable, meaning its value is always inherited from the enclosing scope where the function is defined. This removes the need for using the `bind()` method whenever we want to ensure that `this` always refers to the function's lexical scope.\n\nYou will find yourself using them most often in common functions that take anonymous callback functions, such as event handlers (`onClick`, `$.ajax`) and array processors (`map`, `sort`, etc).\n\n```js\nlet sqRoot = (num) => {\n        return num*num;\n    };\n\n// curly braces are not needed if the function only has one statement, which is implicitly returned\nlet sqRoot = (num) => num * num;\n\n// if there is only one parameter then you don't need parentheses\nlet sqRoot = num => num * num;\n\nconsole.log(`the square root of 3 is ${sqRoot(3)}`); // \"the square root of 3 is 9\"\n\n// when returning objects in a single line you must wrap them in parentheses\nconsole.log([1, 2, 3].map( x => ( {foo: x} ) ));\n```\n\nYou can also use arrow functions with `map`, `filter`, and `reduce`. Reduce applies a function against an accumulator to get a single result. Filter will return values that pass a certain condition. Map performs the given action on every item that is passed to it.\n\n```js\nlet valArr = [1, 2, 3, 4, 5];\n\n// takes in two values at a time and add them until no more exist\nconsole.log(valArr.reduce((a,b) => a + b)); // 15\n\nconsole.log(valArr.filter(v => v % 2 == 0)); // 2, 4\nconsole.log(valArr.map(v => v * 2 )); // 2, 4, 6, 8, 10\n```\n\n## OOP in ES6\n\n### Object literals\n\nES6 improves the syntax of **object literals** by making them more succinct, and making it even easier to create arbitrarily nested and dynamic data objects. Object literals also give us the ability to have computed property keys.\n\n```js\n// ES5 version\nfunction createAnimal(name, owner, mammal){\n    return {\n        name: name,\n        owner: owner,\n        getInfo: function(){\n            return `${this.name} is owned by ${this.owner}`;\n        },\n        address: {\n            street: \"123 Main St\",\n            city: \"Seattle\"\n        }\n    }\n}\n\n// ES6 version\nfunction createAnimal(name, owner, mammal){\n    return {\n        name,\n        owner,\n        ['species' + mammal]: true,\n        getInfo(){\n            return `${this.name} is owned by ${this.owner}`;\n        },\n        address: {\n            street: \"123 Main St\",\n            city: \"Seattle\"\n        }\n    }\n}\n\nvar spot = createAnimal(\"Spot\", \"Jon\");\nconsole.log(spot.getInfo()); // \"Spot is owned by Jon\"\nconsole.log(`${spot.name} is at ${spot.address.street}`); // Spot is at 123 Main St\"\n// we can also get the properties and methods of an object\nconsole.log(Object.getOwnPropertyNames(spot).join(\" \")); // \" name owner getInfo address\"\n```\n\nWe can also store values from objects using something called destructuring.\n\n```js\n// continuing from above code snippet\nlet {name, owner} = spot;\nconsole.log(`Name: ${name}`); // \"Name: Spot\"\nlet {address} = spot;\nconsole.log(`Address: ${address.street}`); // \"Address: 123 Main St\"\n```\n\n### Classes\n\nES6 also provides us with enhanced object literals that look and act nearly identical to typical OOP classes, but in reality they are still using the prototype functions that are inherent in JavaScript. These new classes support constructors, instance and static methods, inheritance, and super calls. They also have `get` and `set` as keywords when defining getter and setter functions. It is convention to use the `_` character at the beginning of property names that are intended to be private, even though this style of naming has no effect on how the code executes.\n\n**Static methods** that are defiend with the `static` keyword are methods that do not depend on a particular instance of a class. They are accessible to all instances of a class and do not need to reference `this`. ES6 does not currently support static properties so they need to be defined outside of the class blueprint, just like they are in ES5.\n\n```js\nclass Mammal {\n    constructor(name){\n        this._name = name;\n    }\n\n    get name(){\n        return this._name;\n    }\n    set name(name){\n        this._name = name;\n    }\n\n    static makeMammal(name){\n        return new Mammal(name);\n    }\n\n    getInfo(){\n        return `${this.name} is a mammal`;\n    }\n}\n// static properties must be defined outside\nMammal.counter = 0;\n\n// create a new Mammal using the constructor function\nlet monkey = new Mammal(\"joe\");\nmonkey.name = \"tim\";\nconsole.log(`Mammal : ${monkey.name}`); // \"Mammal : tim\"\n\n// we can also create a Mammal with the static function\nlet dog = Mammal.makeMammal(\"pupper\");\nconsole.log(`Mammal 2 : ${dog.name}`); // \"Mammal 2 : pupper\"\n\n// Proof that ES6 classes are really JS functions\nconsole.log(typeof Mammal === \"function\"); // true\n```\n\nWe can use the `extends` keyword in ES6 to inherit properties and methods from classes. Calling the `super()` function in the constructor calls the constructor function from the parent class. We can overwrite functions from the inherited class by redefining them.\n\n```js\nclass Marsupial extends Mammal{\n    constructor(name, hasPouch){\n        super(name);\n        this._hasPouch = hasPouch;\n    }\n\n    get hasPouch(){\n        this._hasPouch\n    }\n\n    set hasPuch(hasPouch){\n        this._hasPouch = hasPouch;\n    }\n\n    getInfo(){\n        return `${this.name} is a marsupial`;\n    }\n}\nlet kangaroo = new Marsupial(\"stephan\", true);\nconsole.log(`It is ${kangaroo.hasPouch} that ${kangaroo.name} has a pouch`); // \"It is true that stephan has a pouch\"\nconsole.log(kangaroo.getInfo()); // \"stephan is a marsupial\"\n```\n\n### Abstract classes\n\nAn abstract base class is a class that can not be constructed, it can only be inherited by other classes. Since ES6 does not utilize the `abstract` keyword that is common in other programming languages, you have to use `new.target` instead.\n\nIn a constructor, `new.target` references the class that is being constructed. This allows us to create a check in the constructor that throws an error for objects that we want to be abstract classes.\n\n```js\nclass Foo {\n    constructor(){\n        if(new.target === Foo){\n            throw new Error(\"Foo can not be directly constructed\");\n        }\n    }\n}\n\nclass Bar extends Foo{\n\n}\nlet foo = new Foo(); // Error: Foo can not be directly constructed\n```\n\n## Promises\n\nA **promise** in ES6 is a new feature intended to solve the over abundance of callbacks in JavaScript. It does this by representing an eventual result of an asynchronous operation. The caller registers callbacks with the promise to receive either a promise's eventual value from the async operation or the reason why the promise cannot be fulfilled.\n\nThere are three different states that a promise can be in:\n\n* Unsettled/pending - the async operation has yet to compute its result\n* Settled: fulfilled - the async operation has completed successfully and computed a result to return\n* Settled: rejected - the async operation did not complete successfully, most likely due to an error\n\n```js\n// creating a promise wrapper for setTimeout\nfunction wait(delay = 0) {\n    return new Promise((resolve, reject) => {\n        setTimeout(resolve, delay);\n    });\n}\n// using the promise\nwait(3000)\n    .then(() => {\n        console.log('3 seconds have passed!');\n        return wait(2000);\n    })\n    .then(() => {\n        console.log('5 seconds have passed!');\n        x++;\n    })\n    .catch(error => {\n        console.log(error);\n    })\n    .then(() => {\n        // simulate `finally` clause\n        console.log('clean up');\n    });\n```\n\n## Conclusion\n\nThere is a lot more to promises and every other ES6 feature that was covered here briefly, as well as some other features such as iterators, generators, and new collections which we haven't covered at all. ES6 brings a lot of improvements and is inevitably going to change the way that people program web applications.\n\nRemember to check out the [Learning ES6 Series](https://www.eventbrite.com/engineering/tag/learning-es6/) by Ben Ilegbodu if you want a more in depth look at some of these concepts.",
  "excerpt": "ES6 is the next generation of JavaScript that brings a lot of quality of life improvements for the JavaScript developer. Here we have a look at some of its key features.",
  "date": "Nov. 13th, 2017",
  "featured": false,
  "tags": "JavaScript, ES6, OOP"
}